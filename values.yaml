# Default values for control.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
global:

  #######  PostgreSQL  ########
  ## Supported version  from 9.6.* <
  ## for RDS minimum instance - db.t3.medium / master user set "postgres"
  db:
    image: "postgres:13.7-alpine"
    imagePullPolicy: "IfNotPresent"
    # if internal true - create and use internal postgres container
    # if internal false - enable external db, like aws rds
    internal: false
    ## secret configuration for postgresql
    create: true
    ## pvc name
    persistantVolumeClaimName: "postgresql-pvc"
    secret:
      ## true - secret will be created automaticaly with provided values
      ## false - secret should be created manualy
      create: true
      ## secret name
      name: "postgresql-secret"
      ## for init db and roles dbsuperuser and dbuser cannot be changed (because used as plain text in sql)
      dbsuperuser: "master"
      ## password - for dbsuperuser
      dbsuperuserpwd: "password"
      data:
        dbname: "ctrl"
        dbhost: "POSTGRES_HOST"
        dbport: "5432"
        dbuser: "dbuser"
        dbpwd: "dbpwd"

    # Set false to disable if you don't want to use PGBouncer, recommended - true
    # If true, will create pod with PGBouncer
    bouncer: true
    bouncer_port: 5432
    bouncer_minReplicas: 1
    bouncer_maxReplicas: 6
    bouncer_resources:
      limits:
        cpu: "500m"
        memory: "500Mi"
      requests:
        cpu: "100m"
        memory: "100Mi"
    bouncer_log_level: debug
    # Maximum number of client connections allowed.
    maxclientconn: "100000"
    # How many server connections to allow per user/database pair. Can be overridden in the per-database configuration.
    default_pool_size: "5000"
    # Server is released back to pool after transaction finishes. default: session, see man https://wiki.postgresql.org/wiki/PgBouncer
    # transaction | session
    default_pool_mode: transaction

  ## NO CLUSTER Mode!
  redis:
    # if internal true - create and use internal k8s redis container
    # if internal false - enable external redis, like aws elasticache (Engine Version Compatibility: 3.2.10)
    internal: false
    ## pvc name if it already exist or was created manualy
    persistantVolumeClaimName: "redis-pvc"
    ## secret configuration for redis
    sentinel:
      enable: false
      master_name: "mymaster"
    secret:
      ## true - secret will be created automatically with provided values
      ## false - secret should be created manually
      create: true
      name: "redis-secret"
      # you can specify different servers for redis for cache and PubSub  - or specify the same server in variables
      data:
        # host: "redis-master"
        host: "REDIS_HOST"
        port: "6379"
        password: ""
        # default redis for PubSub
        host_PubSub: "REDIS_HOST"
        port_PubSub: "6379"
        password_PubSub: ""

  #######  Elasticsearch  ########
  ## Supported version 7.17.*
  elasticsearch:
    tag: "k8s"
    # if internal true - create and use internal elasticsearch container
    # if internal false - enable external elasticsearch, like aws elasticsearch service
    internal: false
    ## secret configuration for elasticsearch
    secret:
      ## true - secret will be created automaticaly with provided values
      ## false - secret should be created manualy
      create: true
      name: "elasticsearch-secret"
      data:
        # Set host with ElasticSearch if use external
        # host: "elasticsearch-local"
        host: "ELASTICSEARCH_HOST"
        ## be careful with port - in internal install used 9200, in aws uses 443
        port: 9200
        schema: "http"
      # Optional
      auth_enabled: false
      auth_data:
        username: ""
        password: ""

  elasticsearchLogs:
    tag: "k8s"
    # if internal true - create and use internal elasticsearch container
    # if internal false - enable external elasticsearch, like aws elasticsearch service
    internal: false
    ## secret configuration for elasticsearch
    secret:
      ## true - secret will be created automaticaly with provided values
      ## false - secret should be created manualy
      create: true
      name: "elasticsearch-secret"
      data:
        # Set host with ElasticSearch if use external
        # host: "elasticsearch-local"
        host: "ELASTICSEARCH_HOST"
        ## be careful with port - in internal install used 9200, in aws uses 443
        port: 9200
        schema: "http"
        index: control
      # Optional
      auth_enabled: false
      auth_data:
        username: ""
        password: ""

  ###########################################
  ######## Settings for filesystems #########
  # Define global storage class: efs / nfs / manual
  storage: efs
  # Define global storageClass name
  storageClassName: "control-storage-class-prod"
  persistantVolumeClaimCreate: true
  ######## Settings AWS EFS filesystem   ########
  efs:
    # Set AWS region
    awsRegion: "eu-west-1"
    # Set EFS id
    efsFileSystemId: "fs-07465fb09693c837f"
    ## set true if you choose storage: efs
    enabled: true
  ######## Settings NFS filesystem   ########
  nfs:
    ## set true if you choose storage: nfs
    enabled: false

  imageRegistry: "docker-hub.middleware.biz"
  repotype: "public"

  imageInit:
    repository: docker-hub.middleware.biz/hub.docker.com/library/alpine
    pullPolicy: IfNotPresent
    tag: "3.13"

  imagePullSecrets:
    name: develop-middleware-registry-secret

  deploymentStrategy:
    type: RollingUpdate

  networkPolicy:
    enabled: false
    monitoring:
      # Selector for prometheus namespace
      namespaceSelector:
        name: monitoring
      # Selector for prometheus deploymnets
      podSelector:
        release: prometheus-stack

  nameOverride: ""
  fullnameOverride: ""

  control:
    product: "control"
    # Applications ports
    serverPort: 9000
    cronPort: 9001
    realtimePort: 9005
    frontendPort: 80
    widgetPort: 80
    apiVersion: '1.0'
    # Secret for submitting requests between Control applications.
    apiSecret: "sRk5FM;T(]WbUuFeP8)[f2p[cH9:+)Qm"
    browserExtensionsSecret: "IeV0j4i8ewSDT!FETZ@%69nDiiJ$BKmBCOVq!#%Q"
    googleApiKey: "AIzaSyA36Bi3n5IiQjGiXEGL4pxW0piqGp4nvOs"
    # Superadmin API key
    superAdminApiKey: "P8NTWrKT2fkRjRKNyAm2QjYJa3nxnzhb9xqDxjVx"
    # Supported localizations
    locales:
      - en
    # Time zone from which time is calculated in notification letters.
    timeZone: 2
    session:
      ttl: "2592000"
    requestLimits:
      ip: -1

    auth:
      # Auth settings via Single Account
      disablePublicApiCheck: true
      # Name of client in Single Account
      name: "control-auth-name-public"
      key: "zD8llYwv7i8DeTNZqvzyHMEycBa1RRvJetIo8U8hE5YHgwphZ6TcZ9veVNo4AnDV"
      domain: "account.pre.corezoid.company"

    mainDomain: "control.company" # Use for CORS
    # Sub-domain for Control
    domain: "control-test.eks.control.company"
    # Sub-domain for API Corezoid
    apiCorezoidDomain: "dev.corezoid.company"
    # Sub-domain for Corezoid
    adminCorezoidDomain: "admin.dev.corezoid.company"
    # Sub-domain for Corezoid Widget
    widgetDomain: "widget-test.eks.control.company"

    connectors:
      # SyncApi API login
      apiLogin: 117978
      # SyncApi API secret
      apiSecret: "wGbnULhwvRn049lpmj8TE5P7AzxM7SSqwK5LrgmRcpZXY2R7B6"
      convId: 953085
      syncApiUrl: "https://sync-api.corezoid.company"
    corezoidSyncApiUrl: "https://sync-api.corezoid.company"

    corezoid:
      companyId: "i11111111"
      apiSecret: "12345"
      processes:
        sendEmail:
          directUrl: "https://dev.corezoid.company/api/1/json/public/111/68cb9iusg5555ds36dc474ce987vds"
          convId: 111
        botNotifications:
          directUrl: "https://dev.corezoid.company/api/1/json/public/111/68cb9iusg5555ds36dc474ce987vds"
          convId: 112
        accRegistrations:
          directUrl: "https://dev.corezoid.company/api/1/json/public/112/e5068cb9iusg5555ds36dc474ce987vds"
          convId: 112

    filesStorage:
      eventFiles: "/ebsmnt/attachments"

    webConfig:
      supportEmail: ''
      maxFileSize: '26214400'

    channels:
      gmail:
        clientId: "290556131007-Pn6DrBiuXOIuVAXiqBRLC7TcCMEmrOcu.apps.googleusercontent.com"
        clientSecret: "EKtxLCZEU4zskcEGyevncUm9"
        ignoredDomains: []


    service:
      type: ClusterIP

    terminationGracePeriodSeconds: {}

    frontend:
      pullPolicy: Always
      # Overrides the image tag whose default is the chart appVersion.
      autoscaling:
        enabled: true
        minReplicas: 1
        maxReplicas: 10
      resources:
        limits:
          cpu: 200m
          memory: 600Mi
        requests:
          cpu: 50m
          memory: 100Mi

    realtime:
      pullPolicy: Always
      # Overrides the image tag whose default is the chart appVersion.
      autoscaling:
        enabled: false
        minReplicas: 1
        maxReplicas: 10
        targetCPUUtilizationPercentage: 80
        targetMemoryUtilizationPercentage: 80
      resources:
        limits:
          cpu: 200m
          memory: 600Mi
        requests:
          cpu: 50m
          memory: 100Mi

    server:
      persistantVolumeClaimName: "server-pvc"
      pullPolicy: Always
      # Overrides the image tag whose default is the chart appVersion.
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "9000"
        prometheus.io/scrape: "true"
      autoscaling:
        enabled: true
        minReplicas: 2
        maxReplicas: 4
        targetCPUUtilizationPercentage: 80
        targetMemoryUtilizationPercentage: 80
      resources:
        limits:
          cpu: 500m
          memory: 500Mi
        requests:
          cpu: 100m
          memory: 500Mi

    cron:
      autoscaling:
        enabled: false
        minReplicas: 1
        maxReplicas: 1
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "9000"
        prometheus.io/scrape: "true"
      resources:
        limits:
          cpu: 200m
          memory: 600Mi
        requests:
          cpu: 50m
          memory: 100Mi

    widget:
      pullPolicy: Always
      # Overrides the image tag whose default is the chart appVersion.
      autoscaling:
        enabled: false
        minReplicas: 1
        maxReplicas: 2
      resources:
        limits:
          cpu: 200m
          memory: 600Mi
        requests:
          cpu: 50m
          memory: 100Mi

    serviceAccount:
      # Specifies whether a service account should be created
      create: false
      # Annotations to add to the service account
      annotations: {}
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    podAnnotations: {}

    podSecurityContext: {}
      # fsGroup: 2000

    securityContext: {}
    # securityContext:
    #   runAsUser: 1000
    #   runAsGroup: 1000
    #   runAsNonRoot: true
    #   readOnlyRootFilesystem: true
    #   allowPrivilegeEscalation: false
    #   privileged: false
    #   capabilities:
    #     drop:
    #       - NET_ADMIN
    #       - SYS_ADMIN
    #       - MAC_ADMIN
    #       - SETUID
    #       - SETGID
    #       - FOWNER
    #       - CHOWN
    #       - MKNOD


    ingress:
      enabled: true

    nodeSelector: {}

    tolerations: []

    affinity: {}
    # affinity:
    #   nodeAffinity:
    #     requiredDuringSchedulingIgnoredDuringExecution:
    #       nodeSelectorTerms:
    #         - matchExpressions:
    #             - key: eks.amazonaws.com/nodegroup
    #               operator: In
    #               values:
    #                 - ctrl-nodes-1
